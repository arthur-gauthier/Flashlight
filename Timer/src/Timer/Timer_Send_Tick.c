/*2023-03-30T15:07:49.460529319Z*/

/**********************************************************************
 * Timer_Send_Tick.c
 *
 * generated by : embedded software producer/ESPActivityCCodeGen 0.0.1
 **********************************************************************/

/* Application code for activity "Send Tick" */

#include "Timer_Send_Tick.h"

#include <string.h>
#define ACTIVITY_NAME   "Send Tick"
#define ACTIVITY_PFX    Send_Tick
#define ACTIVIT_ID      _2022x_1ad00ce_1659689071378_428346_4514
#define ACTIVITY        Timer_Send_Tick_struct

/**********************************************************************
 * default event handlers
 **********************************************************************/
static TIMER_SEND_TICK_EVENT_T default_peekEvent(ACTIVITY *instance) {
    return instance->EVENT;
}
static TIMER_SEND_TICK_EVENT_T default_nextEvent(ACTIVITY *instance) {
    (void)instance; /* keep Misra happy */
    return TIMER_SEND_TICK_EVENT_T_NO_EVENT;
}
static Boolean default_sendEvent(ACTIVITY *instance, TIMER_SEND_TICK_EVENT_T event) {
    Boolean ret = FALSE;
    if(instance->EVENT == TIMER_SEND_TICK_EVENT_T_NO_EVENT) {
        instance->EVENT = event;
        ret = TRUE;
    }
    return ret;
}

/**********************************************************************
 * helpers
 **********************************************************************/
static inline Boolean isRunning(ACTIVITY *instance) {
    return (instance->flow[0] != 0u) ? TRUE : FALSE;
}

/**********************************************************************
 * activity init code
 **********************************************************************/
void _basic_Timer_Send_Tick_init(ACTIVITY *instance) {
    if(instance->peekEVENT == NULL) {instance->peekEVENT = default_peekEvent;}
    if(instance->nextEVENT == NULL) {instance->nextEVENT = default_nextEvent;}
    if(instance->sendEVENT == NULL) {instance->sendEVENT = default_sendEvent;}
    instance->EVENT = TIMER_SEND_TICK_EVENT_T_NO_EVENT;

    (void)memset(instance->flow, 0, 1u * sizeof(instance->flow[0]));

    instance->WALL_CLOCK        = (WALLCLOCK_T)0;

    // TODO how to assign events functions
    // instance->node_2_Send_Tick.peekEVENT = instance->peekEVENT;
    // instance->node_2_Send_Tick.nextEVENT = instance->nextEVENT;
    // instance->node_2_Send_Tick.sendEVENT = instance->sendEVENT;
    _basic_Functions_Send_Tick_init(&(instance->node_2_Send_Tick));
}

/**********************************************************************
 * activity exit code
 **********************************************************************/
void _basic_Timer_Send_Tick_end(ACTIVITY *instance) {
    _basic_Functions_Send_Tick_end(&(instance->node_2_Send_Tick));
}

/**********************************************************************
 * activity step code
 **********************************************************************/
Boolean _basic_Timer_Send_Tick(ACTIVITY *instance) {
    /* initialization */
    if(isRunning(instance) == FALSE) {
        instance->flow[0] = 1u; /* SET_FLOW->CallBehaviorAction */
        instance->EVENT = instance->peekEVENT(instance);
    }

    if(1u == (instance->flow[0] & 1u)) { /* TST_FLOW<-InitialNode */
        /* node:_2022x_1ad00ce_1659689071373_957232_4509 */
        Boolean success;
        success = _basic_Functions_Send_Tick(&(instance->node_2_Send_Tick));
        if(success != FALSE) {
            instance->flow[0] ^= 1u; /* CLR_FLOW<-InitialNode */
            instance->flow[0] |= 2u; /* SET_FLOW->ActivityFinalNode */
        }
    }
    if(2u == (instance->flow[0] & 2u)) { /* TST_FLOW<-CallBehaviorAction */
        /* node:_2022x_1ad00ce_1659689071370_920292_4508 */
        (void)memset(instance->flow, 0, 1u * sizeof(instance->flow[0]));
    }

    return (FALSE == isRunning(instance)) ? TRUE : FALSE;
}

/* end of file */
