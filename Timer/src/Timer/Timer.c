/*2023-03-30T15:07:49.430331805Z*/

/**********************************************************************
 * Timer.c
 *
 * generated by : embedded software producer/uml statemachine 0.1.5
 **********************************************************************/

/* Application code for statemachine "Timer" */

#include "Timer.h"

#define STATEMACHINE_NAME   "Timer"
#define STATEMACHINE_PFX    Timer
#define STATEMACHINE_ID     _2022x_1ad00ce_1659687960195_296841_3882
#define STATEMACHINE        Timer_struct

/**********************************************************************
 * prototypes
 **********************************************************************/
static void Ticking_Entry(STATEMACHINE *instance);
static void StateMachine_init(STATEMACHINE *instance);
static void StateMachine_end(STATEMACHINE *instance);

/**********************************************************************
 * handy helpers
 **********************************************************************/
#define light_snd  	instance->light_snd
#define control_snd	instance->control_snd

/**********************************************************************
 * state machine
 **********************************************************************/
void _basic_Timer(STATEMACHINE *instance) {
	if(instance->FIRST != FALSE) {
		instance->FIRST = FALSE;
		instance->CURRENT_STATE_0 = TIMER_STATE_T_INITIAL_0;
		/* INITIAL_0 -> off */
		instance->CURRENT_STATE_0 = TIMER_STATE_T_off;
	}
	switch(instance->CURRENT_STATE_0) {
		case TIMER_STATE_T_off: {
			if( instance->EVENT == TIMER_EVENT_T_On ) {
				/* off -> Ticking */
				Ticking_Entry(instance); /* Entry Send Tick */
				instance->CURRENT_STATE_0 = TIMER_STATE_T_Ticking;
				instance->ENTER_CLOCK_0 = instance->WALL_CLOCK;
				instance->EVENT = TIMER_EVENT_T_NO_EVENT;
			} else {
				/* nothing */;
			}
			break; /* end of off */
		}
		case TIMER_STATE_T_Ticking: {
			if( instance->WALL_CLOCK - instance->ENTER_CLOCK_0 >= (WALLCLOCK_T)1 ) {
				/* Ticking -> Ticking */
				Ticking_Entry(instance); /* Entry Send Tick */
				instance->CURRENT_STATE_0 = TIMER_STATE_T_Ticking;
				instance->ENTER_CLOCK_0 = instance->WALL_CLOCK;
				instance->EVENT = TIMER_EVENT_T_NO_EVENT;
			} else if( instance->EVENT == TIMER_EVENT_T_Off ) {
				/* Ticking -> off */
				instance->CURRENT_STATE_0 = TIMER_STATE_T_off;
				instance->EVENT = TIMER_EVENT_T_NO_EVENT;
			} else {
				/* nothing */;
			}
			break; /* end of Ticking */
		}
		default : break;
	} /* end of switch */
}

/**********************************************************************
 * state machine init code
 **********************************************************************/
void _basic_Timer_init(STATEMACHINE *instance) {
	instance->FIRST = TRUE;
	instance->WALL_CLOCK = (WALLCLOCK_T)0;
	instance->CURRENT_STATE_0 = TIMER_STATE_T_VOID;
	StateMachine_init(instance);
}

/**********************************************************************
 * state machine exit code
 **********************************************************************/
void _basic_Timer_end(STATEMACHINE *instance) {
	StateMachine_end(instance);
}

/**********************************************************************
 * separate code of user-modifiable functions to prevent accidental
 * changes to code above.
 **********************************************************************/
#include "Timer_usr.c"

/* end of file */
