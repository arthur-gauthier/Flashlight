/*2023-03-30T15:07:49.433596872Z*/

/**********************************************************************
 * Timer_itf.c
 *
 * generated by : embedded software producer/uml statemachine 0.1.5
 **********************************************************************/

#include "Timer.h"

#define STATEMACHINE Timer_struct

/**********************************************************************
 * handy helpers
 **********************************************************************/
#define light_snd  	instance->light_snd
#define control_snd	instance->control_snd

/**********************************************************************
 * Timer memory hosting all related information for its own execution
 **********************************************************************/
static int current_index = 0; /* static counter of instances */

 /* array sized with the number of instances */
static STATEMACHINE component_inst_array[NB_INST_TIMER];

/**********************************************************************
 * Init function invoked for component initialization purpose.
 **********************************************************************/
void Timer_init(Rte_Instance inst) {
	STATEMACHINE *instance;
	
	/* we store an instance of the Timer memory in "user_section" area */
	inst->user_section = (void*)&component_inst_array[current_index++];
	
	/* Init instance once user_section is allocated */
	instance = (STATEMACHINE*)inst->user_section;
	
	/* Initialization job which can be done in a separated function or inlined. */
	_basic_Timer_init(instance);
}

/**********************************************************************
 * Main function Body of state machine "Timer"
 **********************************************************************/
void Timer(Rte_Instance inst) {
	STATEMACHINE *instance = (STATEMACHINE*)inst->user_section;
	
	/* read input(s) */
	RTE_Read_control_snd(inst, &(control_snd));
	
	/* handle event(s) */
	instance->EVENT = TIMER_EVENT_T_NO_EVENT;
	if(instance->EVENT == TIMER_EVENT_T_NO_EVENT) {
		SignalEvent_Off_type SignalEvent_Off;
		RTE_Read_InputSignal_Off(inst, &SignalEvent_Off);
		if(SignalEvent_Off.trigger == TRUE) {instance->EVENT = TIMER_EVENT_T_Off;}
	}
	if(instance->EVENT == TIMER_EVENT_T_NO_EVENT) {
		SignalEvent_On_type SignalEvent_On;
		RTE_Read_InputSignal_On(inst, &SignalEvent_On);
		if(SignalEvent_On.trigger == TRUE) {instance->EVENT = TIMER_EVENT_T_On;}
	}
	
	/* update WALL_CLOCK */
	instance->WALL_CLOCK += inst->period;
	
	/* perform step */
	_basic_Timer(instance);
	
	/* write output(s) */
	RTE_Write_light_snd(inst, &light_snd);
if (instance->Ticking_Entry_Send_Tick.node_2_Send_Tick.EVENT == FUNCTIONS_SEND_TICK_EVENT_T_Tick) {
instance->Ticking_Entry_Send_Tick.node_2_Send_Tick.EVENT = FUNCTIONS_SEND_TICK_EVENT_T_NO_EVENT;
RTE_Trigger_light_Tick(inst);
}
}

/**********************************************************************
 * Exit function invoked at execution ending
 **********************************************************************/
void Timer_end(Rte_Instance inst) {
	STATEMACHINE *instance = (STATEMACHINE*)inst->user_section;
	_basic_Timer_end(instance);
}

/* end of file */
